// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v3.14.0
// source: v1/api/game/instance.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "v1.api.game";

/** / Represents the state of the game instance that is currently running */
export enum InstanceStateEnum {
  INITIALIZING = 0,
  RUNNING = 1,
  PAUSED = 2,
  CRASHED = 3,
  ABORTED = 4,
  SHUTTING_DOWN = 5,
  STOPPED = 6,
  UNRECOGNIZED = -1,
}

export function instanceStateEnumFromJSON(object: any): InstanceStateEnum {
  switch (object) {
    case 0:
    case "INITIALIZING":
      return InstanceStateEnum.INITIALIZING;
    case 1:
    case "RUNNING":
      return InstanceStateEnum.RUNNING;
    case 2:
    case "PAUSED":
      return InstanceStateEnum.PAUSED;
    case 3:
    case "CRASHED":
      return InstanceStateEnum.CRASHED;
    case 4:
    case "ABORTED":
      return InstanceStateEnum.ABORTED;
    case 5:
    case "SHUTTING_DOWN":
      return InstanceStateEnum.SHUTTING_DOWN;
    case 6:
    case "STOPPED":
      return InstanceStateEnum.STOPPED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstanceStateEnum.UNRECOGNIZED;
  }
}

export function instanceStateEnumToJSON(object: InstanceStateEnum): string {
  switch (object) {
    case InstanceStateEnum.INITIALIZING:
      return "INITIALIZING";
    case InstanceStateEnum.RUNNING:
      return "RUNNING";
    case InstanceStateEnum.PAUSED:
      return "PAUSED";
    case InstanceStateEnum.CRASHED:
      return "CRASHED";
    case InstanceStateEnum.ABORTED:
      return "ABORTED";
    case InstanceStateEnum.SHUTTING_DOWN:
      return "SHUTTING_DOWN";
    case InstanceStateEnum.STOPPED:
      return "STOPPED";
    case InstanceStateEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** / Available commands to be sent to the game instance */
export enum InstanceCommandEnum {
  START = 0,
  PAUSE = 1,
  RESUME = 2,
  STOP = 3,
  ABORT = 4,
  SHUTDOWN = 5,
  UNRECOGNIZED = -1,
}

export function instanceCommandEnumFromJSON(object: any): InstanceCommandEnum {
  switch (object) {
    case 0:
    case "START":
      return InstanceCommandEnum.START;
    case 1:
    case "PAUSE":
      return InstanceCommandEnum.PAUSE;
    case 2:
    case "RESUME":
      return InstanceCommandEnum.RESUME;
    case 3:
    case "STOP":
      return InstanceCommandEnum.STOP;
    case 4:
    case "ABORT":
      return InstanceCommandEnum.ABORT;
    case 5:
    case "SHUTDOWN":
      return InstanceCommandEnum.SHUTDOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InstanceCommandEnum.UNRECOGNIZED;
  }
}

export function instanceCommandEnumToJSON(object: InstanceCommandEnum): string {
  switch (object) {
    case InstanceCommandEnum.START:
      return "START";
    case InstanceCommandEnum.PAUSE:
      return "PAUSE";
    case InstanceCommandEnum.RESUME:
      return "RESUME";
    case InstanceCommandEnum.STOP:
      return "STOP";
    case InstanceCommandEnum.ABORT:
      return "ABORT";
    case InstanceCommandEnum.SHUTDOWN:
      return "SHUTDOWN";
    case InstanceCommandEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** / Represents the game instance (between App and Game), can be used to trigger operations to run in parent App from child Game container over messages. This would be the local state of the game instance last received. */
export interface Instance {
  state: InstanceStateEnum;
  gameId?: string | undefined;
  playerId?: string | undefined;
  data?: string | undefined;
}

/** / Incoming message from the game instance to the app instance (between Game and App) */
export interface InstanceNotification {
  state: InstanceStateEnum;
  gameId?: string | undefined;
  playerId?: string | undefined;
  data?: string | undefined;
}

/** / Represents the command to be sent to the game instance that is currently running (not the game state data itself) */
export interface InstanceCommandMessage {
  state: InstanceCommandEnum;
  gameId?: string | undefined;
  playerId?: string | undefined;
  data?: string | undefined;
  authConfig?: AuthConfig | undefined;
}

/** / Represents the authentication and configuration for the game instance */
export interface AuthConfig {
  token: string;
  config: { [key: string]: string };
}

export interface AuthConfig_ConfigEntry {
  key: string;
  value: string;
}

function createBaseInstance(): Instance {
  return { state: 0, gameId: undefined, playerId: undefined, data: undefined };
}

export const Instance: MessageFns<Instance> = {
  encode(message: Instance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.gameId !== undefined) {
      writer.uint32(18).string(message.gameId);
    }
    if (message.playerId !== undefined) {
      writer.uint32(26).string(message.playerId);
    }
    if (message.data !== undefined) {
      writer.uint32(34).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Instance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gameId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Instance {
    return {
      state: isSet(object.state) ? instanceStateEnumFromJSON(object.state) : 0,
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : undefined,
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : undefined,
      data: isSet(object.data) ? globalThis.String(object.data) : undefined,
    };
  },

  toJSON(message: Instance): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = instanceStateEnumToJSON(message.state);
    }
    if (message.gameId !== undefined) {
      obj.gameId = message.gameId;
    }
    if (message.playerId !== undefined) {
      obj.playerId = message.playerId;
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Instance>, I>>(base?: I): Instance {
    return Instance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Instance>, I>>(object: I): Instance {
    const message = createBaseInstance();
    message.state = object.state ?? 0;
    message.gameId = object.gameId ?? undefined;
    message.playerId = object.playerId ?? undefined;
    message.data = object.data ?? undefined;
    return message;
  },
};

function createBaseInstanceNotification(): InstanceNotification {
  return { state: 0, gameId: undefined, playerId: undefined, data: undefined };
}

export const InstanceNotification: MessageFns<InstanceNotification> = {
  encode(message: InstanceNotification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.gameId !== undefined) {
      writer.uint32(18).string(message.gameId);
    }
    if (message.playerId !== undefined) {
      writer.uint32(26).string(message.playerId);
    }
    if (message.data !== undefined) {
      writer.uint32(34).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceNotification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceNotification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gameId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceNotification {
    return {
      state: isSet(object.state) ? instanceStateEnumFromJSON(object.state) : 0,
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : undefined,
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : undefined,
      data: isSet(object.data) ? globalThis.String(object.data) : undefined,
    };
  },

  toJSON(message: InstanceNotification): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = instanceStateEnumToJSON(message.state);
    }
    if (message.gameId !== undefined) {
      obj.gameId = message.gameId;
    }
    if (message.playerId !== undefined) {
      obj.playerId = message.playerId;
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceNotification>, I>>(base?: I): InstanceNotification {
    return InstanceNotification.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceNotification>, I>>(object: I): InstanceNotification {
    const message = createBaseInstanceNotification();
    message.state = object.state ?? 0;
    message.gameId = object.gameId ?? undefined;
    message.playerId = object.playerId ?? undefined;
    message.data = object.data ?? undefined;
    return message;
  },
};

function createBaseInstanceCommandMessage(): InstanceCommandMessage {
  return { state: 0, gameId: undefined, playerId: undefined, data: undefined, authConfig: undefined };
}

export const InstanceCommandMessage: MessageFns<InstanceCommandMessage> = {
  encode(message: InstanceCommandMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.gameId !== undefined) {
      writer.uint32(18).string(message.gameId);
    }
    if (message.playerId !== undefined) {
      writer.uint32(26).string(message.playerId);
    }
    if (message.data !== undefined) {
      writer.uint32(34).string(message.data);
    }
    if (message.authConfig !== undefined) {
      AuthConfig.encode(message.authConfig, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstanceCommandMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstanceCommandMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gameId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.authConfig = AuthConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InstanceCommandMessage {
    return {
      state: isSet(object.state) ? instanceCommandEnumFromJSON(object.state) : 0,
      gameId: isSet(object.gameId) ? globalThis.String(object.gameId) : undefined,
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : undefined,
      data: isSet(object.data) ? globalThis.String(object.data) : undefined,
      authConfig: isSet(object.authConfig) ? AuthConfig.fromJSON(object.authConfig) : undefined,
    };
  },

  toJSON(message: InstanceCommandMessage): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = instanceCommandEnumToJSON(message.state);
    }
    if (message.gameId !== undefined) {
      obj.gameId = message.gameId;
    }
    if (message.playerId !== undefined) {
      obj.playerId = message.playerId;
    }
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    if (message.authConfig !== undefined) {
      obj.authConfig = AuthConfig.toJSON(message.authConfig);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InstanceCommandMessage>, I>>(base?: I): InstanceCommandMessage {
    return InstanceCommandMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InstanceCommandMessage>, I>>(object: I): InstanceCommandMessage {
    const message = createBaseInstanceCommandMessage();
    message.state = object.state ?? 0;
    message.gameId = object.gameId ?? undefined;
    message.playerId = object.playerId ?? undefined;
    message.data = object.data ?? undefined;
    message.authConfig = (object.authConfig !== undefined && object.authConfig !== null)
      ? AuthConfig.fromPartial(object.authConfig)
      : undefined;
    return message;
  },
};

function createBaseAuthConfig(): AuthConfig {
  return { token: "", config: {} };
}

export const AuthConfig: MessageFns<AuthConfig> = {
  encode(message: AuthConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    Object.entries(message.config).forEach(([key, value]) => {
      AuthConfig_ConfigEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = AuthConfig_ConfigEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.config[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      config: isObject(object.config)
        ? Object.entries(object.config).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AuthConfig): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.config) {
      const entries = Object.entries(message.config);
      if (entries.length > 0) {
        obj.config = {};
        entries.forEach(([k, v]) => {
          obj.config[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthConfig>, I>>(base?: I): AuthConfig {
    return AuthConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthConfig>, I>>(object: I): AuthConfig {
    const message = createBaseAuthConfig();
    message.token = object.token ?? "";
    message.config = Object.entries(object.config ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAuthConfig_ConfigEntry(): AuthConfig_ConfigEntry {
  return { key: "", value: "" };
}

export const AuthConfig_ConfigEntry: MessageFns<AuthConfig_ConfigEntry> = {
  encode(message: AuthConfig_ConfigEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthConfig_ConfigEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthConfig_ConfigEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthConfig_ConfigEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AuthConfig_ConfigEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthConfig_ConfigEntry>, I>>(base?: I): AuthConfig_ConfigEntry {
    return AuthConfig_ConfigEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthConfig_ConfigEntry>, I>>(object: I): AuthConfig_ConfigEntry {
    const message = createBaseAuthConfig_ConfigEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
